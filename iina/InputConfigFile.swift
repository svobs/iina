//
//  InputConfigFile.swift
//  iina
//
//  Created by Matt Svoboda on 2022.08.10.
//  Copyright Â© 2022 lhc. All rights reserved.
//

import Foundation

// TODO
let USE_LEGACY_CONFIG_UPDATE = true

class InputConfigFile {

  // This should reflect what is on disk at all times
  private var rawLines: [String]

  init() {
    self.rawLines = []
  }

  // This parses the file's lines one by one, skipping lines which are blank or only comments, If a line looks like a key binding,
  // a KeyMapping object is constructed for it, and each KeyMapping makes note of the line number from which it came. A list of the successfully
  // constructed KeyMappings is returned once the entire file has been parsed.
  func parseBindings() -> [KeyMapping] {
    var bindingList: [KeyMapping] = []

    for (lineNumber, rawLine) in self.rawLines.enumerated() {
      if let binding = InputConfigFile.parseSingleLine(rawLine, lineNumber) {
        bindingList.append(binding)
      }
    }

    return bindingList
  }

  func parseLine(_ lineNumber: Int) -> KeyMapping? {
    return InputConfigFile.parseSingleLine(rawLines[lineNumber], lineNumber)
  }

  // Returns a KeyMapping if successful, nil if line has no mapping or is not correct format
  fileprivate static func parseSingleLine(_ rawLine: String, _ lineNumber: Int) -> KeyMapping? {
    var content = rawLine
    var isIINACommand = false
    if content.trimmingCharacters(in: .whitespaces).isEmpty {
      return nil
    } else if content.hasPrefix("#") {
      if content.hasPrefix("#@iina") {
        // extended syntax
        isIINACommand = true
        content = String(content[content.index(content.startIndex, offsetBy: "#@iina".count)...])
      } else {
        // ignore comment line
        return nil
      }
    }
    var comment: String? = nil
    if let sharpIndex = content.firstIndex(of: "#") {
      comment = String(content[content.index(after: sharpIndex)...])
      content = String(content[...content.index(before: sharpIndex)])
    }
    // split
    let splitted = content.split(maxSplits: 1, whereSeparator: { $0 == " " || $0 == "\t"})
    if splitted.count < 2 {
      Logger.log("Skipped corrupted line in input.conf: \(rawLine)", level: .warning)
      return nil  // no command, wrong format
    }
    let key = String(splitted[0]).trimmingCharacters(in: .whitespaces)
    let action = String(splitted[1]).trimmingCharacters(in: .whitespaces)

    return KeyMapping(rawKey: key, rawAction: action, isIINACommand: isIINACommand, comment: comment, bindingID: lineNumber)
  }

  func replaceAllBindings(with newBindings: [KeyMapping]) {
    var newRawLines: [String] = []
    if USE_LEGACY_CONFIG_UPDATE {
      // Legacy algorithm: just overwrite the previous file with a one-line comment, a blank line, and one line for each binding
      newRawLines.append("# Generated by IINA")
      newRawLines.append("")
      for newBinding in newBindings {
        newRawLines.append(newBinding.confFileFormat)
      }
    } else {
      // New algorithm: make effort to preserve formatting of the existing file, not just the bindings
      var prevLineNumber: Int = 0
      for newBinding in newBindings {
        if let newLineNumber = newBinding.bindingID {
          if newLineNumber >= rawLines.count {
            Logger.fatal("Cannot save binding: its ID (\(newLineNumber)) is invalid. Expected a maximum of: \(rawLines.count - 1)")
          }

          // Fill in lines which were not parsed as bindings
          appendNonBindingLines(between: prevLineNumber, and: newLineNumber, to: &newRawLines)

          guard let prevBinding = parseLine(newLineNumber) else {
            Logger.fatal("Failed to parse previously parsed line (\(newLineNumber))")
          }
          if prevBinding.rawEquals(newBinding) {
            // Preserve formatting wherever possible: use previous raw text for line instead of reconstructing it
            newRawLines.append(rawLines[prevLineNumber])
          } else {
            // Binding was changed: convert it to line format
            newRawLines.append(newBinding.confFileFormat)
          }

          prevLineNumber = newLineNumber
        } else { // no bindingID: must be a new binding
          newRawLines.append(newBinding.confFileFormat)
        }
      }

      appendNonBindingLines(between: prevLineNumber, and: rawLines.count, to: &newRawLines)
    }
    rawLines = newRawLines
  }

  // For all the lines between lineNumberStart and lineNumberEnd (exclusive), append to lineArray if they are not parsable bindings
  private func appendNonBindingLines(between lineNumberStart: Int, and lineNumberEnd: Int, to lineArray: inout [String]) {
    for inBetweenLineNumber in (lineNumberStart+1)..<lineNumberEnd {
      appendNonBindingLine(at: inBetweenLineNumber, to: &lineArray)
    }
  }

  private func appendNonBindingLine(at lineNumber: Int, to lineArray: inout [String]) {
    if parseLine(lineNumber) == nil {
      // No binding - maybe comment or some other thing. Write it back to file
      lineArray.append(rawLines[lineNumber])
    } else {
      // If it was not included in the new bindings, treat it as a remove.
      Logger.log("Binding on line \(lineNumber) removed")
    }
  }

  func write(to path: String) throws {
    let fileContent: String = rawLines.joined(separator: "\n")
    try fileContent.write(toFile: path, atomically: true, encoding: .utf8)
  }

  static func generateInputConf(from mappings: [KeyMapping]) -> String {
    return mappings.reduce("# Generated by IINA\n\n", { prevLines, km in prevLines + "\(km.confFileFormat)\n" })
  }

  // Returns nil if cannot read file
  static func loadFile(at path: String) -> InputConfigFile? {
    guard let reader = StreamReader(path: path) else {
      return nil
    }
    let result = InputConfigFile()

    while let rawLine: String = reader.nextLine() {      // ignore empty lines
      result.rawLines.append(rawLine)
    }
    return result
  }

}
