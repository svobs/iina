//
//  InputConfigFileData.swift
//  iina
//
//  Created by Matt Svoboda on 2022.08.10.
//  Copyright Â© 2022 lhc. All rights reserved.
//

import Foundation

// Represents an input config file which has been loaded into memory.
class InputConfigFileData {
  // At least one of its fields should be non-nil.
  // Only Lines with non-nil `rawFileContent` are present in the file on disk.
  // A Line struct can include additional in-memory state (if `bindingOverride` is non-nil) which is not present on disk.
  private struct Line {
    let rawFileContent: String?  // reflects content on disk
    let bindingOverride: KeyMapping?  // only exists in memory. Useful for maintaining edits even while they are not parseable

    init(_ rawFileContent: String? = nil, bindingOverride: KeyMapping? = nil) {
      self.rawFileContent = rawFileContent
      self.bindingOverride = bindingOverride
    }
  }

  // The path of the source file on disk
  let filePath: String

  // This should reflect what is on disk at all times
  private var lines: [Line]

  init(filePath: String) {
    self.filePath = filePath
    self.lines = []
  }

  // This parses the file's lines one by one, skipping lines which are blank or only comments, If a line looks like a key binding,
  // a KeyMapping object is constructed for it, and each KeyMapping makes note of the line number from which it came. A list of the successfully
  // constructed KeyMappings is returned once the entire file has been parsed.
  func parseBindings() -> [KeyMapping] {
    var bindingList: [KeyMapping] = []

    var linesNew: [Line] = []
    for line in self.lines {
      let lineIndex = linesNew.count
      if let binding = line.bindingOverride {
        // Note: `lineIndex` includes bindingOverrides and thus may be greater than the equivalent line number in the physical file

        let bindingNew = binding.clone(bindingID: lineIndex)
        bindingList.append(bindingNew)
        linesNew.append(Line(line.rawFileContent, bindingOverride: bindingNew))
      } else if let rawFileContent = line.rawFileContent, let binding = InputConfigFileData.parseRawLine(rawFileContent, lineIndex) {
        bindingList.append(binding)
        linesNew.append(line)
      }
    }
    self.lines = linesNew

    return bindingList
  }

  private func parseLine(_ lineIndex: Int) -> KeyMapping? {
    if let rawLine = lines[lineIndex].rawFileContent {
      return InputConfigFileData.parseRawLine(rawLine, lineIndex)
    }
    return nil
  }

  // Returns a KeyMapping if successful, nil if line has no mapping or is not correct format
  fileprivate static func parseRawLine(_ rawLine: String, _ lineIndex: Int? = nil) -> KeyMapping? {
    var content = rawLine
    var isIINACommand = false
    if content.trimmingCharacters(in: .whitespaces).isEmpty {
      return nil
    } else if content.hasPrefix("#") {
      if content.hasPrefix("#@iina") {
        // extended syntax
        isIINACommand = true
        content = String(content[content.index(content.startIndex, offsetBy: "#@iina".count)...])
      } else {
        // ignore comment line
        return nil
      }
    }
    var comment: String? = nil
    if let sharpIndex = content.firstIndex(of: "#") {
      comment = String(content[content.index(after: sharpIndex)...])
      content = String(content[...content.index(before: sharpIndex)])
    }
    // split
    let splitted = content.split(maxSplits: 1, whereSeparator: { $0 == " " || $0 == "\t"})
    if splitted.count < 2 {
      Logger.log("Could not parse line from input config: \"\(rawLine)\"", level: .warning)
      return nil  // no command, wrong format
    }
    let key = String(splitted[0]).trimmingCharacters(in: .whitespaces)
    let action = String(splitted[1]).trimmingCharacters(in: .whitespaces)

    return KeyMapping(rawKey: key, rawAction: action, isIINACommand: isIINACommand, comment: comment, bindingID: lineIndex)
  }

  func replaceAllBindings(with newBindings: [KeyMapping]) {
    if Preference.bool(for: .retainIgnoredLinesInInputConfigFiles) {
      // New algorithm: make effort to preserve formatting of the existing file, not just the bindings
      lines = replaceAllBindingsRetainingIgnoredLines(newBindings)
    } else {
      // Legacy algorithm: just overwrite the previous file with: 1 standard comment, 1 blank line, and 1 line per valid binding
      lines = replaceAllBindingsDiscardingIgnoredLines(newBindings)
    }
  }

  private func replaceAllBindingsDiscardingIgnoredLines(_ newBindings: [KeyMapping]) -> [Line] {
    var newLines: [Line] = []
    newLines.append(Line("# Generated by IINA"))
    newLines.append(Line(""))
    for newBinding in newBindings {
      let rawLine = newBinding.confFileFormat
      if InputConfigFileData.parseRawLine(rawLine) == nil {
        Logger.log("While serializing bindings: looks like an active edit: \(newBinding)", level: .verbose)
        if let lineIndex = newBinding.bindingID,
           lineIndex <= self.lines.count,
           let fileRawLine = self.lines[lineIndex].rawFileContent {
          // line previously existed
          newLines.append(Line(fileRawLine, bindingOverride: newBinding))
        } else {
          // line was added
          newLines.append(Line(bindingOverride: newBinding))
        }
      } else {
        // valid binding
        newLines.append(Line(rawLine))
      }
    }
    return newLines
  }

  // FIXME: need to confirm this works, and verify logic is correct for override lines
  private func replaceAllBindingsRetainingIgnoredLines(_ newBindings: [KeyMapping]) -> [Line] {
    var newLines: [Line] = []

    var prevLineNumber: Int = 0
    for newBinding in newBindings {
      if let newLineNumber = newBinding.bindingID {
        if newLineNumber >= lines.count {
          Logger.fatal("Cannot save binding: its ID (\(newLineNumber)) is invalid. Expected a maximum of: \(lines.count - 1)")
        }

        // Fill in lines which were not parsed as bindings
        appendNonBindingLines(between: prevLineNumber, and: newLineNumber, to: &newLines)

        guard let prevBinding = parseLine(newLineNumber) else {
          Logger.fatal("Failed to parse previously parsed line (\(newLineNumber))")
        }
        if prevBinding.rawEquals(newBinding) {
          // Preserve formatting wherever possible: use previous raw text for line instead of reconstructing it
          newLines.append(lines[prevLineNumber])
        } else {
          // Binding was changed: convert it to line format
          newLines.append(Line(newBinding.confFileFormat))
        }

        prevLineNumber = newLineNumber
      } else { // no bindingID: must be a new binding
        newLines.append(Line(newBinding.confFileFormat))
      }
    }
    appendNonBindingLines(between: prevLineNumber, and: lines.count, to: &newLines)

    return newLines
  }

  // For all the lines between lineIndexStart and lineIndexEnd (exclusive), append to lineArray if they are not parsable bindings
  private func appendNonBindingLines(between lineIndexStart: Int, and lineIndexEnd: Int, to lineArray: inout [Line]) {
    for inBetweenLineNumber in (lineIndexStart+1)..<lineIndexEnd {
      appendNonBindingLine(at: inBetweenLineNumber, to: &lineArray)
    }
  }

  private func appendNonBindingLine(at lineIndex: Int, to lineArray: inout [Line]) {
    if parseLine(lineIndex) == nil {
      // No binding - maybe comment or some other thing. Write it back to file
      lineArray.append(lines[lineIndex])
    } else {
      // If it was not included in the new bindings, treat it as a remove.
      Logger.log("Binding on line \(lineIndex) removed")
    }
  }

  func saveToDisk() throws {
    let fileContent: String = lines.filter({ $0.rawFileContent != nil}).map({ $0.rawFileContent! }).joined(separator: "\n")
    try fileContent.write(toFile: self.filePath, atomically: true, encoding: .utf8)
  }

  // Returns nil if cannot read file
  static func loadFile(at path: String) -> InputConfigFileData? {
    guard let reader = StreamReader(path: path) else {
      // on error
      Logger.log("Error loading bindings from path: \"\(path)\"", level: .error)
      let fileName = URL(fileURLWithPath: path).lastPathComponent
      let alertInfo = AlertInfo(key: "keybinding_config.error", args: [fileName])
      NotificationCenter.default.post(Notification(name: .iinaKeyBindingErrorOccurred, object: alertInfo))

      return nil
    }
    let result = InputConfigFileData(filePath: path)

    while let rawFileContent: String = reader.nextLine() {      // ignore empty lines
      result.lines.append(Line(rawFileContent))
    }
    return result
  }

}
